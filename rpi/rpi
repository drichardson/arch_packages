#!/usr/bin/python3
# PYTHON_ARGCOMPLETE_OK

import sys
import argparse
import subprocess
import os.path

# Conditional support for bash completion
try:
    import argcomplete
    has_argcomplete=True
except ImportError:
    has_argcomplete=False


RPI_MOUNT_DIR=os.path.expanduser("~/rpi_mnt")
RPI_MOUNT_ROOT=os.path.join(RPI_MOUNT_DIR, "root")
RPI_MOUNT_BOOT=os.path.join(RPI_MOUNT_DIR, "boot")
SD_CARD_BOOT_PARTITION="/dev/sdc1"
SD_CARD_ROOT_PARTITION="/dev/sdc2"
KERNEL_SRC=os.path.expanduser("~/control_linux")
RASPBERRYPI_TOOLS=os.path.expanduser("~/raspberrypi-tools")
CCPREFIX=os.path.expanduser("~/x-tools6h/arm-unknown-linux-gnueabihf/bin/arm-unknown-linux-gnueabihf-")

def true_or_die(condition, message):
    if not condition:
        print("ERROR: ", message, file=sys.stderr)
        sys.exit(1)

def sudo(argv):
    a=["/usr/bin/sudo"]
    a.extend(argv)
    return subprocess.call(a)

def mount():
    print("Mounting SD card partitions")
    rc1 = sudo(["/usr/bin/mount", SD_CARD_BOOT_PARTITION, RPI_MOUNT_BOOT])
    rc2 = sudo(["/usr/bin/mount", SD_CARD_ROOT_PARTITION, RPI_MOUNT_ROOT])
    true_or_die(rc1 == 0 and rc2 == 0, "A mount command failed")

def umount():
    print("Unmounting SD card partitions")
    rc = sudo(["/usr/bin/umount", RPI_MOUNT_BOOT, RPI_MOUNT_ROOT])
    true_or_die(rc == 0, "umount failed")

def mkimage():
    mkimage_dir=os.path.join(RASPBERRYPI_TOOLS, "mkimage")
    zImage_path = os.path.join(KERNEL_SRC, "arch/arm/boot/zImage")
    argv=["./imagetool-uncompressed.py", zImage_path]
    print("Uncompressing kernel image to ", mkimage_dir)
    cmd = subprocess.Popen(argv, cwd=mkimage_dir)
    rc = cmd.wait()
    true_or_die(rc == 0, "imagetool-uncompressed.py failed")

def cpimage():
    kernel_img=os.path.join(RASPBERRYPI_TOOLS, "mkimage/kernel.img")
    dest=os.path.join(RPI_MOUNT_BOOT, "kernel-new.img")
    print("Copying kernel image to ", dest)
    rc = sudo(["/usr/bin/cp", kernel_img, dest])
    true_or_die(rc == 0, "failed to copy kernel image")

def cpmodules():
    argv = ["/usr/bin/tar"]
    cmd = subprocess.Popen(argv, cwd=mkimage_dir)
    pass

def make_call_args(make_options):
    cross_compile="CROSS_COMPILE=" + CCPREFIX
    arch="ARCH=arm"
    argv = ["/usr/bin/make", "-C", KERNEL_SRC, "-j8", cross_compile, arch]
    argv.extend(make_options)
    return argv

def make(make_options):
    cmd = subprocess.Popen(make_call_args(make_options))
    rc = cmd.wait()
    true_or_die(rc == 0, "make failed")

def make_if_not_modules_install(make_options):
    print("Options:", make_options)
    true_or_die(False, "NONO")
    true_or_die("modules_install" not in make_options, "Use modules_install command instead")
    make(make_options)

def modules_install():
    # Make sure the root directory is mounted.
    true_or_die(os.path.ismount(RPI_MOUNT_ROOT), "Root partition not mounted. Try rpi mount")

    # Create a clean modules_tmp, so that old modules aren't accidentally included.
    #subprocess.call(["/usr/bin/rm", "-rf", INSTALL_MOD_PATH])
    #rc = subprocess.call(["/usr/bin/mkdir", INSTALL_MOD_PATH])
    #true_or_die(rc == 0, "mkdir failed to create " + INSTALL_MOD_PATH)

    # Make sure the modules are built as the current user before running sudo make modules_install
    make(["modules"])

    # Run kernel makefile's modules_install and firmware_install targets.
    mod_path = "INSTALL_MOD_PATH="+RPI_MOUNT_ROOT
    rc = sudo(make_call_args([mod_path, "modules_install", "firmware_install"]))
    true_or_die(rc == 0, "Error installing modules and firmware")

def all():
    make([])
    mkimage()
    mount()
    modules_install()
    cpimage()
    umount()

def parse(argv):
    p = argparse.ArgumentParser(description="Raspberry Pi dev workflow utility")

    options=[]

    handlers = {
        "mount" : mount,
        "umount" : umount,
        "mkimage" : mkimage,
        "cpimage" : cpimage,
        "cpmodules" : cpmodules,
        "make" : lambda: make_if_not_modules_install(options),
        "modules_install" : modules_install,
        "all" : all,
    }

    p.add_argument("command", choices=dict.keys(handlers))
    p.add_argument("options", nargs='*')

    # bash and zsh completion
    if has_argcomplete:
        argcomplete.autocomplete(p)

    result = p.parse_args(argv)
    result.handler = handlers[result.command]

    # update options for use of the lambda above
    options=result.options

    return result

def main():
    args = parse(sys.argv[1:])
    print("Using CCPREFIX: ", CCPREFIX)
    print("Using KERNEL_SRC: ", KERNEL_SRC)
    args.handler()
    print("OK", args.command)

main()
